#!/usr/bin/env python3
"""compile-claude-routing.py

Generates a compact Skill Routing Rules block from routing/skill-rules.json.

Output destinations:
  --target global   → ~/.claude/CLAUDE_ROUTING.md  (preferred: separate file)
  --target project  → <project-dir>/CLAUDE.md       (appends/replaces block)

The generated block is delimited with markers so it can be replaced idempotently.

Usage:
    python3 scripts/compile-claude-routing.py [OPTIONS]

Options:
    --target global|project   Where to write (default: global)
    --project-dir DIR         Project root for --target project (default: cwd)
    --profile core|full       Include skills up to this profile (default: full)
    --dry-run                 Print output without writing
    -h, --help                Show help

Why routing?
    A routing block teaches the agent which skill to load for a given task.
    This reduces context waste — the agent loads only the right skill, not all.

Why opt-in?
    Routing tables add ~200 tokens of always-loaded context. CORE keeps that
    budget free. Enable it once you have multiple skills and want reliable
    auto-routing.

Enable:
    python3 scripts/compile-claude-routing.py --target global
    # or for the current project:
    python3 scripts/compile-claude-routing.py --target project --project-dir .
"""

import argparse
import json
import sys
from datetime import datetime
from pathlib import Path

MARKER_START = "<!-- KIT-ROUTING:START -->"
MARKER_END = "<!-- KIT-ROUTING:END -->"


def load_rules(rules_file: Path) -> dict:
    if not rules_file.exists():
        print(f"Error: routing rules not found at {rules_file}", file=sys.stderr)
        print("  Expected: routing/skill-rules.json in the kit directory", file=sys.stderr)
        sys.exit(1)
    try:
        return json.loads(rules_file.read_text())
    except json.JSONDecodeError as e:
        print(f"Error: invalid JSON in {rules_file}: {e}", file=sys.stderr)
        sys.exit(1)


def filter_skills(skills: list, profile: str) -> list:
    """Return skills included in the given profile."""
    result = []
    for skill in skills:
        skill_profile = skill.get("profile", "core")
        if profile == "full" or skill_profile == "core":
            result.append(skill)
    return result


def generate_block(rules: dict, profile: str) -> str:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    all_skills = rules.get("skills", [])
    skills = filter_skills(all_skills, profile)

    lines = [
        MARKER_START + "\n",
        f"<!-- Auto-generated by compile-claude-routing.py on {timestamp} — do not edit manually -->\n",
        "<!-- Regenerate: python3 scripts/compile-claude-routing.py -->\n",
        "\n",
        "## Skill Routing Rules\n",
        "\n",
        "Match user intent → load the corresponding skill before writing code.\n",
        "\n",
        "| Keywords | Skill | Description |\n",
        "|----------|-------|-------------|\n",
    ]

    for skill in skills:
        keywords = ", ".join(f"`{k}`" for k in skill.get("keywords", [])[:3])
        name = skill["name"]
        desc = skill.get("description", "")
        lines.append(f"| {keywords} | `{name}` | {desc} |\n")

    lines.append("\n")
    lines.append("### Detailed Patterns\n\n")

    for skill in skills:
        name = skill["name"]
        desc = skill.get("description", "")
        patterns = skill.get("intentPatterns", [])
        profile_tag = skill.get("profile", "core").upper()
        lines.append(f"**`{name}`** `[{profile_tag}]` — {desc}\n")
        if patterns:
            pattern_str = " | ".join(f"`{p}`" for p in patterns[:4])
            lines.append(f"Triggers: {pattern_str}\n")
        lines.append("\n")

    lines.append(MARKER_END + "\n")
    return "".join(lines)


def write_output(content: str, out_file: Path, dry_run: bool) -> None:
    if dry_run:
        print("=== DRY RUN — output that would be written ===\n")
        print(content)
        return

    existing = ""
    if out_file.exists():
        existing = out_file.read_text()

    # Remove previous generated block (idempotent re-run)
    start_idx = existing.find(MARKER_START)
    end_idx = existing.find(MARKER_END)
    if start_idx != -1 and end_idx != -1:
        before = existing[:start_idx].rstrip()
        after = existing[end_idx + len(MARKER_END):].lstrip()
        existing = (before + "\n\n" + after).strip()

    if existing.strip():
        updated = existing.rstrip() + "\n\n" + content
    else:
        updated = content

    out_file.parent.mkdir(parents=True, exist_ok=True)
    out_file.write_text(updated)
    print(f"Written: {out_file}")


def main():
    parser = argparse.ArgumentParser(
        description="Compile skill routing rules into CLAUDE.md or CLAUDE_ROUTING.md",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "--target",
        choices=["global", "project"],
        default="global",
        help="global → ~/.claude/CLAUDE_ROUTING.md, project → <project-dir>/CLAUDE.md",
    )
    parser.add_argument(
        "--project-dir",
        default=".",
        help="Project root for --target project (default: cwd)",
    )
    parser.add_argument(
        "--profile",
        choices=["core", "full"],
        default="full",
        help="Include skills up to this profile (default: full)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print output without writing",
    )
    args = parser.parse_args()

    script_dir = Path(__file__).parent
    kit_dir = script_dir.parent
    rules_file = kit_dir / "routing" / "skill-rules.json"

    rules = load_rules(rules_file)
    skills = filter_skills(rules.get("skills", []), args.profile)
    content = generate_block(rules, args.profile)

    if args.target == "global":
        out_file = Path.home() / ".claude" / "CLAUDE_ROUTING.md"
    else:
        out_file = Path(args.project_dir).resolve() / "CLAUDE.md"

    write_output(content, out_file, args.dry_run)

    if not args.dry_run:
        print(f"Profile:         {args.profile}")
        print(f"Skills included: {len(skills)}")
        if args.target == "global":
            print(f"\nRouting file loaded by Claude Code automatically from: {out_file}")
        else:
            print(f"\nRouting block appended to: {out_file}")


if __name__ == "__main__":
    main()